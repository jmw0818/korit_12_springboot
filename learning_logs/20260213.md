# 📂 02.13 수업 내용  
# 📍 안내사항

# 🟩 SpringBoot Lesson

## 🟢 Gradle
- 초창기 Build System 설정했던 적이 있었다. 두 가지 중 SpringBoot와의 연관성을 위해 Gradle을 적용한다.

- Gradle의 구성(Config) 파일은 build.gradle에서 수행된다. 프로젝트의 요구사항에 맞게 사용자가 지정 가능하며 프로젝트 컴파일에 필요한 외부 라이브러리 및 프레임워크 등 _프로젝트의 의존성_ 에 대한 정보를 포함한다. (devtools / lombok / web / h2와 같은 부분들을 dependencies에 정의 했었다)

```java
plugins {
	id 'java'
	id 'org.springframework.boot' version '3.5.11-SNAPSHOT'
	id 'io.spring.dependency-management' version '1.1.7'
}

group = 'com.temp'
version = '0.0.1-SNAPSHOT'
description = 'Demo project for Spring Boot'

java {
	toolchain {
		languageVersion = JavaLanguageVersion.of(17)
	}
}

configurations {
	compileOnly {
		extendsFrom annotationProcessor
	}
}

repositories {
	mavenCentral()
	maven { url = 'https://repo.spring.io/snapshot' }
}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	compileOnly 'org.projectlombok:lombok'
	developmentOnly 'org.springframework.boot:spring-boot-devtools'
	annotationProcessor 'org.projectlombok:lombok'

	runtimeOnly 'com.h2database:h2'

	testImplementation 'org.springframework.boot:spring-boot-starter-test'
	testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
}

tasks.named('test') {
	useJUnitPlatform()
}

```

### build.gradle의 일반적인 파일 항목 목록
1. 플러그인(plugins) : 플러그인 블록은 프로젝트에 쓰이는 Gradle 플러그인을 정의하는 곳으로, SpringBoot 버전을 정의한다.
2. 리포지토리(repositories) : 의존성을 해결하는 데 쓰이는 의존성 리포지토리를 정의한다. (Maven Central 리포지토리를 이용했다. start.spring.io에서 자동 생성함)
3. 의존성(dependencies) : 프로젝트에서 이용되는 의존성을 지정한다.
4. 태스크(tasks) : 테스트 등의 빌드 프로세스의 일부를 정의한다.

# 🟩 스프링 이니셜라이저 활용 프로젝트 생성(Spring Initializr)
1. https://start.spring.io
2. 의존성
    - Spring Boot DevTools :  자동 재시작 기능을 제공하는 개발자 도구 포함 / 변경 내용을 저장할 때마다 애플리케이션이 자동 다시 실행된다.
    - Spring Boot Starter Web : 풀스택 개발을 위한 옵션으로 자체 내장 톰캣 서버를 제공한다.

# 🟩 main 단계에서의 springboot 프로젝트의 애너테이션
1. `@EnableAutoConfiguration` : 스프링부트의 자동 구성을 활성화. 프로젝트가 의존성에 따라 자동으로 구성된다. 예를들어 spring-boot-starter-web 의존성이 있는 경우 스프링 부트는 웹 애플리케이션을 개발 중이라고 인식하고 그에 따라 애플리케이션 구성을 가진다.
2. `@ComponentScan` : 스프링부트 컴포넌트 검색으로, 애플리케이션의 모든 컴포넌트를 찾을 수 있도록 한다.
3. `@Configuration` : 빈(bean) 정의를 제공하는 소스로 쓸 수 있는 클래스를 지정한다.

## 🟢 로그 및 문제 해결
1. Logging은 애플리케이션의 흐름을 모니터링하는데 이용할 수 있고, 오류를 포착하는 방식이다. 스타터 패키지 내에 Logback이 존재하는데, SLF4J(simple logging facade for java)의 축약어이다.
2. logger.info(); 로그 메시지를 console에 출력한다.
    - 로깅 수준 종류 :  TRACE / DEBUG / INFO / WARN / ERROR / FATAL / OFF 수준이 있다. 이를 `application.properties`에서 정의한다. (`logging.level.root=DEBUG`로 작성함) TRACE 버전의 경우 모든 세부 동작 정보를 다 추적하는 상태로 가장 최상위 수준이다. default 수준은 INFO에 해당한다.
3. port number : 8080이다. 바꿔서 사용할 수 있지만 (mariaDB는 3310으로 사용했음) 그대로 사용하겠다.
    - 실행 중일 때 또 실행 버튼 눌러서 터지는 경우가 있다. 잘 정지하자.

# 🟩 의존성 주입(Dependency Injection : DI)
- 의존성 주입은 구성 요소 간의 _느슨한 결합_ 을 이용하여 코드를 유연하고 유지 관리 및 테스트하기 쉽게 만들어주는 요인이다.

## 🟢 의존성 주입 소개
- 의존성 주입은 다른 객체에 의존하는 객체를 만들 수 있는 소프트웨어 개발 기법으로, 클래스 간의 상호작용을 도우면서 동시에 클래스를 독립적으로 유지시킨다.
- sevice : 클라이언트가 이용할 수 있는 클래스(의존성)를 의미, h2database / lombok etc
- client : 의존성을 이용하는 클래스, Logger를 CardatabaseApplication에서 이용했다.
- Injector : 의존성을 의존클래스에 전달하는 기능을 담당한다.

```java
public class Car {
  private Owner owner;
  public Car() {
    owner = new Owner();
  }
}
```
이상의 코드는 클라이언트 클래스인 Car가 서비스 클래스인 Owner의 객체를 생성하기 때문에 의존성 주입이 없다. (즉, 직접 생성하기 때문에 요청 과정이 없음)

```java
public class Car {
  private Owner owner;
  public Car(Owner owner) {
    this.owner = owner;
  }
}
```
서비스 객체(owner)가 클라이언트 클래스(Car)에서 직접 생성되지 않고, 매개변수로 전달된다. (즉, CarMain 같은 곳에서 owner 객체를 생성해서 넣어줘야만 함)

- 서비스 클래스는 추상 클래스일수도 있다. 이 경우 클라이언트 클래스에서 해당 클래스의 어떤 구현이든 이용할 수 있고, 테스트 중에서는 모형(Mock)을 이용할 수도 있다.

### 의존성 주입 방식
1. 생성자 주입(Constructor Injection) :
의존성이 클라이언트 클래스 생성자에 전달되는 방식이다. 생성자 주입은 필수 의존성에 이용하는 것이 좋다.
2. 세터 주입(Setter Injection) :
의존성이 세터를 통해 제동되는 방식.
```java
public class Car {
  private Owner owner;
  public void setOwner(Owner owner) {
    this.owner = owner;
  }
}

public class CarMain {
  public static void main (String[] args) {
    Car car1 = new Car();
    Car car2 = new Car();

    Owner owner1 = new Owner();
    car1.setOwner(owner1);
    car2.setOwner(owner1);
  }
}
```
이상의 코드의 세터 주입은 의존성이 없더라도 일단 객체를 기본 생성자로 만들 수 있기 때문에 더 유연하다. 생성자 주입의 경우 AllArgsConstructor이기 때문에 일단 Owner가 만들어져야 Car 객첼르 만들 수 있겠다.

즉, 의존성 주입은 코드 자체의 의존성을 줄이고, 코드를 재사용하기 쉽게(car1에도 car2에도 owner1을 쓴다는 점) 테스트할 수 있도록 해준다.

## 🟢 SpringBoot에서의 의존성 주입 이용
- 스프링 프레임워크에서 의존성 주입은 `ApplicationContext`를 통해서 이루어진다. 이는 객체(bean)와 객체의 의존성을 생성하고 관리하는 역할을 한다.

- 스프링부트는 애플리케이션 클래스를 검색하여 특정 애너에티션(`@Service`, `@Repository`, `@Controller` 등)이 있는 클래스를 빈으로 등록한다. 의존성 주입을 통해 빈을 주입하는게 가능하다.

- 일반적인 방법은 `생성자 주입`이다.

- 객체가 생성될 때 필요한 모든 의존성을 반드시 이용하게 하므로 가장 권장되는 방식이다. 가장 보편적인 상황은 특정 작업을 위해 데이터베이스에 대한 접근이 필요한 경우인데, 스프링부트에서는 DB에 접근하는 클래스를 `리포지토리` 클래스라고 한다.
```java
public class Car {
  private final CarRepository carRepository;
  
  public Car(CarRepository carRepository) {
    this.carRepository = carRepository;
  }
  carRepository.findAll();
}
```
그런데 클래스 생성자가 여러 개 있는 경우에는 `@Autowired` 애너테이션을 이용하여 의존성 주입에 이용되는 생성자를 정의해야 한다.

- `세터 주입` : 선택적 의존성인 경우나, 프로그램 실행 중에 의존성 수정하는 경우에 사용한다.
```java
@Service
public class AppUserService {
  private AppUserRepository userRepository;

  @Autowired
  public void setAppUserRepository(AppUserRepository userRepository) {
    this.userRepository = userRepository;
  }
}
```
- `필드 주입` : 의존성을 필드에 직접 주입한다. 단순하지만 오류가 발생할 가능성이 높다. 그리고 테스트용의 객체를 별개로 생성할 수가 없어서 테스트 하기에도 까다롭다.
```java
@Service
public class CarDatabaseService implements CarService {
  // 카데이터베이스서비스가 있고, 인터페이스가 있다고 가정
}

public class CarController {
  @Autowired
  private CarDatabaseService carDatabaseService;
}
```
```java
public class CarController {
  private CarDatabaseService carDatabaseService = new CarDatabaseService();
}
```
두 코드 동일하다.



# 🚨발생한 문제

# 📖 복습 & 확인
✔️ 내용
💡📌📍🚩🚨⚠️